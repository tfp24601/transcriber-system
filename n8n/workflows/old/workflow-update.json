{
  "nodes": [
    {
      "parameters": {
        "path": "transcribe-job",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [0, 0],
      "id": "ca262d4d-c7b8-490b-8eec-d54b50668ff4",
      "name": "Transcribe Job Webhook",
      "webhookId": "284d76d2-966f-4af1-85be-752cbe55f1f1"
    },
    {
      "parameters": {
        "jsCode": "const data = $input.first().body;\nconst recordingId = data.recordingId;\nconst mode = data.mode;\nconst audioPath = data.audioPath;\n\nreturn {\n  recordingId,\n  mode,\n  audioPath,\n  timestamp: new Date().toISOString()\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [208, 0],
      "id": "59d83345-d752-44ab-9241-5de9b7ba3de5",
      "name": "Parse Job Data"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "338ea13a-cd34-4b39-9265-c4de039dd0ce",
              "leftValue": "={{ $node[\"Parse Job Data\"].json[\"mode\"] }}",
              "rightValue": "single",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [416, 0],
      "id": "c206d6b5-13ab-4ab3-b8eb-54cbee0d04c9",
      "name": "Check Mode"
    },
    {
      "parameters": {
        "operation": "read",
        "fileSelector": "={{ $node[\"Parse Job Data\"].json[\"audioPath\"] }}"
      },
      "type": "n8n-nodes-base.readBinaryFiles",
      "typeVersion": 1,
      "position": [624, -96],
      "id": "bc10d5a1-fb81-444a-a704-3077260bc14b",
      "name": "Read Audio File (single)"
    },
    {
      "parameters": {
        "operation": "read",
        "fileSelector": "={{ $node[\"Parse Job Data\"].json[\"audioPath\"] }}"
      },
      "type": "n8n-nodes-base.readBinaryFiles",
      "typeVersion": 1,
      "position": [624, 64],
      "id": "fbb8c13e-06f9-4117-b627-65b48655344a",
      "name": "Read Audio File (multi)"
    },
    {
      "parameters": {
        "jsCode": "// Process transcription result for single mode\nconst transcription = $input.first().json;\nconst recordingId = $node[\"Parse Job Data\"].json.recordingId;\nconst audioPath = $node[\"Parse Job Data\"].json.audioPath;\nconst userId = audioPath.split('/')[3]; // Extract from path\n\n// Prepare file paths\nconst transcriptDir = `/data/transcripts/${userId}`;\nconst textPath = `${transcriptDir}/${recordingId}.txt`;\nconst vttPath = `${transcriptDir}/${recordingId}.vtt`;\nconst srtPath = `${transcriptDir}/${recordingId}.srt`;\nconst jsonPath = `${transcriptDir}/${recordingId}.json`;\n\n// Extract text and metadata\nconst transcriptText = transcription.text || '';\nconst language = transcription.language || 'unknown';\nconst duration = transcription.duration || 0;\n\n// Generate VTT format\nlet vttContent = 'WEBVTT\\n\\n';\nif (transcription.segments) {\n  transcription.segments.forEach((segment, index) => {\n    const start = formatTime(segment.start);\n    const end = formatTime(segment.end);\n    vttContent += `${index + 1}\\n${start} --> ${end}\\n${segment.text.trim()}\\n\\n`;\n  });\n}\n\n// Generate SRT format\nlet srtContent = '';\nif (transcription.segments) {\n  transcription.segments.forEach((segment, index) => {\n    const start = formatSRTTime(segment.start);\n    const end = formatSRTTime(segment.end);\n    srtContent += `${index + 1}\\n${start} --> ${end}\\n${segment.text.trim()}\\n\\n`;\n  });\n}\n\nfunction formatTime(seconds) {\n  const hrs = Math.floor(seconds / 3600);\n  const mins = Math.floor((seconds % 3600) / 60);\n  const secs = (seconds % 60).toFixed(3);\n  return `${hrs.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.padStart(6, '0')}`;\n}\n\nfunction formatSRTTime(seconds) {\n  const hrs = Math.floor(seconds / 3600);\n  const mins = Math.floor((seconds % 3600) / 60);\n  const secs = (seconds % 60).toFixed(3).replace('.', ',');\n  return `${hrs.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.padStart(6, '0')}`;\n}\n\nreturn {\n  recordingId,\n  userId,\n  transcriptDir,\n  textPath,\n  vttPath,\n  srtPath,\n  jsonPath,\n  transcriptText,\n  vttContent,\n  srtContent,\n  jsonContent: JSON.stringify(transcription, null, 2),\n  language,\n  duration,\n  mode: 'single',\n  status: 'done',\n  completed_at: new Date().toISOString(),\n  processing_time_seconds: duration\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1136, -96],
      "id": "a8dcdebd-0abb-47ae-b1f8-645b4cd2f6bf",
      "name": "Process Single Result"
    },
    {
      "parameters": {
        "jsCode": "// Process transcription + diarization result for multi mode\nconst diarization = $input.first().json;\nconst transcription = $node[\"Multi Speaker Transcribe\"].json;\nconst recordingId = $node[\"Parse Job Data\"].json.recordingId;\nconst audioPath = $node[\"Parse Job Data\"].json.audioPath;\nconst userId = audioPath.split('/')[3];\n\n// Prepare file paths\nconst transcriptDir = `/data/transcripts/${userId}`;\nconst textPath = `${transcriptDir}/${recordingId}.txt`;\nconst vttPath = `${transcriptDir}/${recordingId}.vtt`;\nconst srtPath = `${transcriptDir}/${recordingId}.srt`;\nconst jsonPath = `${transcriptDir}/${recordingId}.json`;\nconst diarizationPath = `${transcriptDir}/${recordingId}_diarization.json`;\n\n// Generate combined transcript with speaker labels\nlet transcriptText = '';\nlet vttContent = 'WEBVTT\\n\\n';\nlet srtContent = '';\n\nif (diarization.segments) {\n  diarization.segments.forEach((segment, index) => {\n    const speaker = segment.speaker || 'Speaker';\n    const text = segment.text || '';\n    transcriptText += `${speaker}: ${text}\\n\\n`;\n    \n    const start = formatTime(segment.start);\n    const end = formatTime(segment.end);\n    \n    // VTT format\n    vttContent += `${index + 1}\\n${start} --> ${end}\\n${speaker}: ${text}\\n\\n`;\n    \n    // SRT format \n    const srtStart = formatSRTTime(segment.start);\n    const srtEnd = formatSRTTime(segment.end);\n    srtContent += `${index + 1}\\n${srtStart} --> ${srtEnd}\\n${speaker}: ${text}\\n\\n`;\n  });\n}\n\nfunction formatTime(seconds) {\n  const hrs = Math.floor(seconds / 3600);\n  const mins = Math.floor((seconds % 3600) / 60);\n  const secs = (seconds % 60).toFixed(3);\n  return `${hrs.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.padStart(6, '0')}`;\n}\n\nfunction formatSRTTime(seconds) {\n  const hrs = Math.floor(seconds / 3600);\n  const mins = Math.floor((seconds % 3600) / 60);\n  const secs = (seconds % 60).toFixed(3).replace('.', ',');\n  return `${hrs.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.padStart(6, '0')}`;\n}\n\nreturn {\n  recordingId,\n  userId,\n  transcriptDir,\n  textPath,\n  vttPath,\n  srtPath,\n  jsonPath,\n  diarizationPath,\n  transcriptText,\n  vttContent,\n  srtContent,\n  jsonContent: JSON.stringify(transcription, null, 2),\n  diarizationContent: JSON.stringify(diarization, null, 2),\n  language: transcription.language || 'unknown',\n  duration: transcription.duration || 0,\n  speakerCount: diarization.num_speakers || 0,\n  mode: 'multi',\n  status: 'done',\n  completed_at: new Date().toISOString(),\n  processing_time_seconds: transcription.duration || 0\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1216, 64],
      "id": "42d9dc68-f3cb-4a5d-9705-9566955bd355",
      "name": "Process Multi Result"
    }
  ]
}